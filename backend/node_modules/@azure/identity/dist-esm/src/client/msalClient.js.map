{"version":3,"file":"msalClient.js","sourceRoot":"","sources":["../../../src/client/msalClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CredentialUnavailable } from \"./errors\";\nimport {\n  PublicClientApplication,\n  Configuration,\n  AuthorizationCodeRequest,\n  AuthenticationResult,\n  DeviceCodeRequest,\n  ConfidentialClientApplication,\n  ClientCredentialRequest,\n  NetworkRequestOptions,\n  NetworkResponse,\n  INetworkModule\n} from \"@azure/msal-node\";\nimport axios, { AxiosRequestConfig } from \"axios\";\n\nimport { IdentityClient, TokenCredentialOptions } from \"./identityClient\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { credentialLogger } from \"../util/logging\";\nimport { NodeAuthOptions } from \"@azure/msal-node/dist/config/Configuration\";\n\nconst logger = credentialLogger(\"InteractiveBrowserCredential\");\n\n/**\n * The record to use to find the cached tokens in the cache\n */\nexport interface AuthenticationRecord {\n  /**\n   * The associated authority, if used\n   */\n  authority?: string;\n\n  /**\n   * The home account Id\n   */\n  homeAccountId: string;\n\n  /**\n   * The login environment, eg \"login.windows.net\"\n   */\n  environment: string;\n\n  /**\n   * The associated tenant ID\n   */\n  tenantId: string;\n\n  /**\n   * Local, tenant-specific account identifer for this account object, usually used in legacy cases\n   */\n  localAccountId: string;\n\n  /**\n   * The username of the logged in account\n   */\n  username: string;\n}\n\nexport class AuthenticationRequired extends CredentialUnavailable {}\n\nexport class MsalClient {\n  private persistenceEnabled: boolean;\n  private authenticationRecord: AuthenticationRecord | undefined;\n  private identityClient: IdentityClient;\n  private pca: PublicClientApplication | undefined;\n  private cca: ConfidentialClientApplication | undefined;\n  private msalConfig: NodeAuthOptions;\n\n  constructor(\n    msalConfig: NodeAuthOptions,\n    persistenceEnabled: boolean,\n    authenticationRecord?: AuthenticationRecord,\n    options?: TokenCredentialOptions\n  ) {\n    this.identityClient = new IdentityClient(options);\n    this.msalConfig = msalConfig;\n    this.persistenceEnabled = persistenceEnabled;\n    this.authenticationRecord = authenticationRecord;\n  }\n\n  async prepareClientApplications(): Promise<void> {\n    // If we've already initialized the public client application, return\n    if (this.pca) {\n      return;\n    }\n\n    // Construct the public client application, since it hasn't been initialized, yet\n    const clientConfig: Configuration = {\n      auth: this.msalConfig,\n      cache: undefined,\n      system: { networkClient: this.identityClient }\n    };\n\n    this.pca = new PublicClientApplication(clientConfig);\n  }\n\n  async acquireTokenFromCache(scopes: string[]): Promise<AccessToken | null> {\n    await this.prepareClientApplications();\n\n    if (!this.persistenceEnabled || !this.authenticationRecord) {\n      throw new AuthenticationRequired();\n    }\n\n    const silentRequest = {\n      account: this.authenticationRecord!,\n      scopes\n    };\n\n    try {\n      const response = await this.pca!.acquireTokenSilent(silentRequest);\n      logger.info(\"Successful silent token acquisition\");\n      if (response && response.expiresOn) {\n        return {\n          expiresOnTimestamp: response.expiresOn.getTime(),\n          token: response.accessToken\n        };\n      } else {\n        throw new AuthenticationRequired(\"Could not authenticate silently using the cache\");\n      }\n    } catch (e) {\n      throw new AuthenticationRequired(\"Could not authenticate silently using the cache\");\n    }\n  }\n\n  async getAuthCodeUrl(request: { scopes: string[]; redirectUri: string }): Promise<string> {\n    await this.prepareClientApplications();\n\n    return this.pca!.getAuthCodeUrl(request);\n  }\n\n  async acquireTokenByCode(\n    request: AuthorizationCodeRequest\n  ): Promise<AuthenticationResult | null> {\n    await this.prepareClientApplications();\n\n    return this.pca!.acquireTokenByCode(request);\n  }\n\n  async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null> {\n    await this.prepareClientApplications();\n\n    return this.pca!.acquireTokenByDeviceCode(request);\n  }\n\n  async acquireTokenByClientCredential(\n    request: ClientCredentialRequest\n  ): Promise<AuthenticationResult | null> {\n    await this.prepareClientApplications();\n\n    return this.cca!.acquireTokenByClientCredential(request);\n  }\n}\n\nexport enum HttpMethod {\n  GET = \"get\",\n  POST = \"post\"\n}\n/**\n * This class implements the API for network requests.\n */\nexport class HttpClient implements INetworkModule {\n  /**\n   * Http Get request\n   * @param url -\n   * @param options -\n   */\n  async sendGetRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions\n  ): Promise<NetworkResponse<T>> {\n    const request: AxiosRequestConfig = {\n      method: HttpMethod.GET,\n      url: url,\n      headers: options && options.headers,\n      validateStatus: () => true\n    };\n\n    const response = await axios(request);\n    const out = {\n      headers: response.headers,\n      body: response.data as T,\n      status: response.status\n    };\n    return out;\n  }\n\n  /**\n   * Http Post request\n   * @param url -\n   * @param options -\n   */\n  async sendPostRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions\n  ): Promise<NetworkResponse<T>> {\n    const request: AxiosRequestConfig = {\n      method: HttpMethod.POST,\n      url: url,\n      data: (options && options.body) || \"\",\n      headers: options && options.headers,\n      validateStatus: () => true\n    };\n\n    const response = await axios(request);\n    const out = {\n      headers: response.headers,\n      body: response.data as T,\n      status: response.status\n    };\n\n    return out;\n  }\n}\n"]}