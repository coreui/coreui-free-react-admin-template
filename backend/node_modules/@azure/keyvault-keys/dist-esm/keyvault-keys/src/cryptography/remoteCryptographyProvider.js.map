{"version":3,"file":"remoteCryptographyProvider.js","sourceRoot":"","sources":["../../../../src/cryptography/remoteCryptographyProvider.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n\nimport {\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"../cryptographyClientModels\";\nimport { SDK_VERSION } from \"../constants\";\nimport { UnwrapResult } from \"../cryptographyClientModels\";\nimport { KeyVaultClient } from \"../generated\";\nimport { parseKeyVaultKeyIdentifier } from \"../identifier\";\nimport {\n  CryptographyClientOptions,\n  GetKeyOptions,\n  KeyVaultKey,\n  LATEST_API_VERSION,\n} from \"../keysModels\";\nimport { getKeyFromKeyBundle } from \"../transformations\";\nimport { createHash } from \"./crypto\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./models\";\nimport { logger } from \"../log\";\nimport { createKeyVaultChallengeCallbacks } from \"../../../keyvault-common/src\";\nimport { tracingClient } from \"../tracing\";\n\n/**\n * The remote cryptography provider is used to run crypto operations against KeyVault.\n * @internal\n */\nexport class RemoteCryptographyProvider implements CryptographyProvider {\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {},\n  ) {\n    this.client = getOrInitializeClient(credential, pipelineOptions);\n\n    this.key = key;\n\n    let keyId: string;\n    if (typeof key === \"string\") {\n      keyId = key;\n    } else {\n      keyId = key.id!;\n    }\n\n    try {\n      const parsed = parseKeyVaultKeyIdentifier(keyId);\n      if (parsed.name === \"\") {\n        throw new Error(\"Could not find 'name' of key in key URL\");\n      }\n\n      if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n        throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n      }\n\n      this.vaultUrl = parsed.vaultUrl;\n      this.name = parsed.name;\n      this.version = parsed.version ?? \"\";\n    } catch (err: any) {\n      logger.error(err);\n\n      throw new Error(`${keyId} is not a valid Key Vault key ID`);\n    }\n  }\n\n  // The remote client supports all algorithms and all operations.\n  isSupported(_algorithm: string, _operation: CryptographyProviderOperation): boolean {\n    return true;\n  }\n\n  encrypt(\n    encryptParameters: EncryptParameters,\n    options: EncryptOptions = {},\n  ): Promise<EncryptResult> {\n    const { algorithm, plaintext, ...params } = encryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.encrypt\",\n      requestOptions,\n      async (updatedOptions) => {\n        const result = await this.client.encrypt(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          plaintext,\n          updatedOptions,\n        );\n\n        return {\n          algorithm: encryptParameters.algorithm,\n          result: result.result!,\n          keyID: this.getKeyID(),\n          additionalAuthenticatedData: result.additionalAuthenticatedData,\n          authenticationTag: result.authenticationTag,\n          iv: result.iv,\n        };\n      },\n    );\n  }\n\n  decrypt(\n    decryptParameters: DecryptParameters,\n    options: DecryptOptions = {},\n  ): Promise<DecryptResult> {\n    const { algorithm, ciphertext, ...params } = decryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.decrypt\",\n      requestOptions,\n      async (updatedOptions) => {\n        const result = await this.client.decrypt(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          ciphertext,\n          updatedOptions,\n        );\n        return {\n          result: result.result!,\n          keyID: this.getKeyID(),\n          algorithm,\n        };\n      },\n    );\n  }\n\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    options: WrapKeyOptions = {},\n  ): Promise<WrapResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.wrapKey\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.wrapKey(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          keyToWrap,\n          updatedOptions,\n        );\n\n        return {\n          result: result.result!,\n          algorithm,\n          keyID: this.getKeyID(),\n        };\n      },\n    );\n  }\n\n  unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {},\n  ): Promise<UnwrapResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.unwrapKey\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.unwrapKey(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          encryptedKey,\n          updatedOptions,\n        );\n\n        return {\n          result: result.result!,\n          algorithm,\n          keyID: this.getKeyID(),\n        };\n      },\n    );\n  }\n\n  sign(algorithm: string, digest: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.sign\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.sign(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          updatedOptions,\n        );\n\n        return { result: result.result!, algorithm, keyID: this.getKeyID() };\n      },\n    );\n  }\n\n  verifyData(\n    algorithm: string,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {},\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.verifyData\",\n      options,\n      async (updatedOptions) => {\n        const hash = await createHash(algorithm, data);\n        return this.verify(algorithm, hash, signature, updatedOptions);\n      },\n    );\n  }\n\n  verify(\n    algorithm: string,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {},\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.verify\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.verify(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          signature,\n          updatedOptions,\n        );\n        return {\n          result: response.value ? response.value : false,\n          keyID: this.getKeyID(),\n        };\n      },\n    );\n  }\n\n  signData(algorithm: string, data: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.signData\",\n      options,\n      async (updatedOptions) => {\n        const digest = await createHash(algorithm, data);\n        const result = await this.client.sign(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          updatedOptions,\n        );\n        return { result: result.result!, algorithm, keyID: this.getKeyID() };\n      },\n    );\n  }\n\n  /**\n   * The base URL to the vault.\n   */\n  readonly vaultUrl: string;\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyId(): string | undefined {\n    return this.getKeyID();\n  }\n\n  /**\n   * Gets the {@link KeyVaultKey} used for cryptography operations, fetching it\n   * from KeyVault if necessary.\n   * @param options - Additional options.\n   */\n  getKey(options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.getKey\",\n      options,\n      async (updatedOptions) => {\n        if (typeof this.key === \"string\") {\n          if (!this.name || this.name === \"\") {\n            throw new Error(\"getKey requires a key with a name\");\n          }\n          const response = await this.client.getKey(\n            this.vaultUrl,\n            this.name,\n            options && options.version ? options.version : this.version ? this.version : \"\",\n            updatedOptions,\n          );\n          this.key = getKeyFromKeyBundle(response);\n        }\n        return this.key;\n      },\n    );\n  }\n\n  /**\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private client: KeyVaultClient;\n\n  /**\n   * A reference to the key used for the cryptographic operations.\n   * Based on what was provided to the CryptographyClient constructor,\n   * it can be either a string with the URL of a Key Vault Key, or an already parsed {@link KeyVaultKey}.\n   */\n  private key: string | KeyVaultKey;\n\n  /**\n   * Name of the key the client represents\n   */\n  private name: string;\n\n  /**\n   * Version of the key the client represents\n   */\n  private version: string;\n\n  /**\n   * Attempts to retrieve the ID of the key.\n   */\n  private getKeyID(): string | undefined {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.id;\n    } else {\n      kid = this.key;\n    }\n\n    return kid;\n  }\n}\n\n/**\n * A helper method to either get the passed down generated client or initialize a new one.\n * An already constructed generated client may be passed down from {@link KeyClient} in which case we should reuse it.\n *\n * @internal\n * @param credential - The credential to use when initializing a new client.\n * @param options - The options for constructing a client or the underlying client if one already exists.\n * @returns - A generated client instance\n */\nfunction getOrInitializeClient(\n  credential: TokenCredential,\n  options: CryptographyClientOptions & { generatedClient?: KeyVaultClient },\n): KeyVaultClient {\n  if (options.generatedClient) {\n    return options.generatedClient;\n  }\n\n  const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n  const userAgentOptions = options.userAgentOptions;\n\n  options.userAgentOptions = {\n    userAgentPrefix:\n      userAgentOptions && userAgentOptions.userAgentPrefix\n        ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n        : libInfo,\n  };\n\n  const authPolicy = bearerTokenAuthenticationPolicy({\n    credential,\n    scopes: [], // Scopes are going to be defined by the challenge callbacks.\n    challengeCallbacks: createKeyVaultChallengeCallbacks(options),\n  });\n\n  const internalPipelineOptions = {\n    ...options,\n    loggingOptions: {\n      logger: logger.info,\n      allowedHeaderNames: [\n        \"x-ms-keyvault-region\",\n        \"x-ms-keyvault-network-info\",\n        \"x-ms-keyvault-service-version\",\n      ],\n    },\n  };\n\n  const client = new KeyVaultClient(\n    options.serviceVersion || LATEST_API_VERSION,\n    internalPipelineOptions,\n  );\n  client.pipeline.addPolicy(authPolicy);\n\n  return client;\n}\n"]}